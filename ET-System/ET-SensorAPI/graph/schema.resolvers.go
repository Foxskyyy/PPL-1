package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.70

import (
	"ET-SensorAPI/config"
	"ET-SensorAPI/graph/model"
	"ET-SensorAPI/models"
	"ET-SensorAPI/utils"
	"context"
	"encoding/json"
	"errors"
	"strconv"
)

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, email string, password string) (*model.AuthPayload, error) {
	user, err := utils.AuthenticateUser(email, password)
	if err != nil {
		return nil, err
	}

	code, _ := utils.GenerateOTP()
	token, _, err := utils.GenerateToken(user.ID)
	if err != nil {
		return nil, errors.New("failed to generate verification token")
	}

	if err := utils.SendVerificationEmail(email, code); err != nil {
		return nil, errors.New("failed to send verification email")
	}

	groupIDs := utils.FetchUserGroupIDs(user.ID)
	var groups []*model.UserGroup
	for _, id := range groupIDs {
		groups = append(groups, &model.UserGroup{ID: strconv.Itoa(int(id))})
	}

	return &model.AuthPayload{
		User: &model.User{
			ID:        strconv.Itoa(int(user.ID)),
			Username:  user.Username,
			Email:     user.Email,
			Verified:  user.Verified,
			CreatedAt: user.CreatedAt,
			Groups:    groups,
		},
		Token: token,
	}, nil
}

// Register is the resolver for the register field.
func (r *mutationResolver) Register(ctx context.Context, username string, email string, password string) (*string, error) {
	var exists models.User
	if err := config.DB.Where("email = ?", email).First(&exists).Error; err == nil {
		return nil, errors.New("email already registered")
	}

	hashed, err := utils.HashPassword(password)
	if err != nil {
		return nil, errors.New("failed to hash password")
	}

	token, _ := utils.GenerateOTP()
	newUser := models.User{
		Username:    username,
		Email:       email,
		Password:    hashed,
		Verified:    false,
		VerifyToken: token,
	}

	if err := config.DB.Create(&newUser).Error; err != nil {
		return nil, errors.New("failed to create user")
	}

	if err := utils.SendVerificationEmail(email, token); err != nil {
		return nil, errors.New("failed to send verification email")
	}

	successMessage := "Registration successful. Please check your email for verification."
	return &successMessage, nil
}

// AssignUserToGroup is the resolver for the assignUserToGroup field.
func (r *mutationResolver) AssignUserToGroup(ctx context.Context, userID int32, userGroupID int32) (*string, error) {
	var user models.User
	if err := config.DB.First(&user, userID).Error; err != nil {
		return nil, errors.New("user not found")
	}

	var group models.UserGroup
	if err := config.DB.First(&group, userGroupID).Error; err != nil {
		return nil, errors.New("group not found")
	}

	var count int64
	config.DB.Model(&models.UserGroupMember{}).Where("user_group_id = ?", group.ID).Count(&count)
	if count >= 4 {
		return nil, errors.New("user group cannot have more than 4 users")
	}

	membership := models.UserGroupMember{UserID: user.ID, UserGroupID: group.ID}
	if err := config.DB.Create(&membership).Error; err != nil {
		return nil, errors.New("failed to assign user to group")
	}

	successMessage := "User assigned to group successfully"
	return &successMessage, nil
}

// VerifyEmail is the resolver for the verifyEmail field.
func (r *mutationResolver) VerifyEmail(ctx context.Context, email string, token string) (*string, error) {
	var user models.User
	if err := config.DB.Where("email = ? AND verify_token = ?", token).First(&user).Error; err != nil {
		return nil, errors.New("invalid or expired token")
	}

	user.Verified = true
	user.VerifyToken = ""

	if err := config.DB.Save(&user).Error; err != nil {
		return nil, errors.New("failed to verify email")
	}

	successMessage := "Email verified successfully."
	return &successMessage, nil
}

func (r *mutationResolver) ResendVerificationEmail(ctx context.Context, email string) (*string, error) {
	user, err := utils.GetUserByEmail(email)
	if err != nil {
		return nil, errors.New("user not found")
	}

	if user.Verified {
		return nil, errors.New("email is already verified")
	}

	accessToken, _, err := utils.GenerateToken(user.ID)
	if err != nil {
		return nil, errors.New("failed to generate verification token")
	}

	if err := utils.SendVerificationEmail(user.Email, accessToken); err != nil {
		return nil, errors.New("failed to send verification email")
	}

	successMessage := "Verification email sent successfully"
	return &successMessage, nil
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context) ([]*model.User, error) {
	var users []models.User
	if err := config.DB.Find(&users).Error; err != nil {
		return nil, err
	}

	var result []*model.User
	for _, u := range users {
		groupIDs := utils.FetchUserGroupIDs(u.ID)
		var groups []*model.UserGroup
		for _, id := range groupIDs {
			groups = append(groups, &model.UserGroup{ID: strconv.Itoa(int(id))})
		}

		result = append(result, &model.User{
			ID:        strconv.Itoa(int(u.ID)),
			Username:  u.Username,
			Email:     u.Email,
			Verified:  u.Verified,
			CreatedAt: u.CreatedAt,
			Groups:    groups,
		})
	}
	return result, nil
}

// UserGroups is the resolver for the userGroups field.
func (r *queryResolver) UserGroups(ctx context.Context) ([]*model.UserGroup, error) {
	var groups []models.UserGroup
	if err := config.DB.Preload("Devices.WaterUsages").Find(&groups).Error; err != nil {
		return nil, err
	}

	var result []*model.UserGroup
	for _, g := range groups {
		users := utils.FetchGroupUsers(g.ID)
		var devices []*model.Device
		for _, d := range g.Devices {
			var waterUsages []*model.WaterUsage
			for _, wu := range d.WaterUsages {
				waterUsages = append(waterUsages, &model.WaterUsage{
					FlowRate:   wu.FlowRate,
					TotalUsage: wu.TotalUsage,
					RecordedAt: wu.RecordedAt,
				})
			}

			devices = append(devices, &model.Device{
				ID:          d.ID,
				Name:        d.Name,
				Location:    d.Location,
				CreatedAt:   d.CreatedAt,
				WaterUsages: waterUsages,
			})
		}
		result = append(result, &model.UserGroup{
			ID:        strconv.Itoa(int(g.ID)),
			Name:      g.Name,
			CreatedAt: g.CreatedAt,
			Devices:   devices,
			Users:     users,
		})
	}
	return result, nil
}

// Devices is the resolver for the devices field.
func (r *queryResolver) Devices(ctx context.Context) ([]*model.Device, error) {
	var devices []models.Device
	if err := config.DB.Preload("WaterUsages").Find(&devices).Error; err != nil {
		return nil, err
	}

	var result []*model.Device
	for _, d := range devices {
		var waterUsages []*model.WaterUsage
		for _, wu := range d.WaterUsages {
			waterUsages = append(waterUsages, &model.WaterUsage{
				FlowRate:   wu.FlowRate,
				TotalUsage: wu.TotalUsage,
				RecordedAt: wu.RecordedAt,
			})
		}
		result = append(result, &model.Device{
			ID:          d.ID,
			Name:        d.Name,
			Location:    d.Location,
			CreatedAt:   d.CreatedAt,
			WaterUsages: waterUsages,
		})
	}
	return result, nil
}

// WaterUsages is the resolver for the waterUsages field.
func (r *queryResolver) WaterUsages(ctx context.Context) ([]*model.WaterUsage, error) {
	var usages []models.WaterUsage
	if err := config.DB.Preload("Device").Find(&usages).Error; err != nil {
		return nil, err
	}

	var result []*model.WaterUsage
	for _, u := range usages {
		result = append(result, &model.WaterUsage{
			FlowRate:   u.FlowRate,
			TotalUsage: u.TotalUsage,
			RecordedAt: u.RecordedAt,
			Device: &model.Device{
				ID:        u.Device.ID,
				Name:      u.Device.Name,
				Location:  u.Device.Location,
				CreatedAt: u.Device.CreatedAt,
			},
		})
	}
	return result, nil
}

// DeepSeekAnalysis is the resolver for the deepSeekAnalysis field.
func (r *queryResolver) DeepSeekAnalysis(ctx context.Context, userID int32) (*model.DeepSeekResponse, error) {
	water, err := utils.GetUserUsageData(uint(userID))
	if err != nil {
		return nil, err
	}

	usage := map[string]interface{}{
		"waterUsage": water,
	}
	jsonData, err := json.Marshal(usage)
	if err != nil {
		return nil, err
	}

	analysis, err := utils.AnalyzeUsageData(string(jsonData))
	if err != nil {
		return nil, err
	}

	return &model.DeepSeekResponse{Analysis: &analysis}, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
